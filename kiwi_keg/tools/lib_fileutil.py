# Copyright (c) 2025 SUSE Software Solutions Germany GmbH. All rights reserved.
#
# This file is part of keg.
#
# keg is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# keg is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with keg. If not, see <http://www.gnu.org/licenses/>
#
import filecmp
import hashlib
import logging
import os
import re
import subprocess
import sys

from difflib import Differ


def files_equivalent(filename, dir1, dir2, ignore_kiwi_version):
    path1 = os.path.join(dir1, filename)
    path2 = os.path.join(dir2, filename)

    if not os.path.exists(path1) or not os.path.exists(path2):
        return False

    if filename.endswith('.kiwi'):
        return kiwi_files_equivalent(path1, path2, ignore_kiwi_version)

    if 'tar' in filename.split('.'):
        return tar_files_equivalent(path1, path2)

    return filecmp.cmp(path1, path2, shallow=False)


def kiwi_files_equivalent(old_kiwi, new_kiwi, ignore_version_change):
    """
    Compares two given kiwi files. It ignores the 'generated by keg'
    line as it contains a time stamp, and optionally the image version,
    if parameter ignore_version_change is set.

    It does not try to establish whether the files are truly equivalent.
    Any other change aside from the mentioned will result in False.
    """
    with open(old_kiwi, 'r') as fh:
        old_kiwi_content = fh.readlines()
    with open(new_kiwi, 'r') as fh:
        new_kiwi_content = fh.readlines()

    differ = Differ()
    diff = differ.compare(old_kiwi_content, new_kiwi_content)
    ignore_str = 'generated by keg on'
    if ignore_version_change:
        ignore_str += r'|<version>[0123456789\.]+</version>'
    ignore_regex = re.compile(ignore_str)

    for d in diff:
        if d[0] in '-+' and not ignore_regex.search(d):
            return False

    return True


def tar_files_equivalent(file1, file2):
    """
    Compares the content of the two given tar files. If the included files
    are identical but the order differs it will return False.
    """
    result = subprocess.run(
        ['tar', 'xf', file1, '-O'],
        stdout=subprocess.PIPE
    )
    sum1 = hashlib.sha256(result.stdout).digest()
    result = subprocess.run(
        ['tar', 'xf', file2, '-O'],
        stdout=subprocess.PIPE
    )
    sum2 = hashlib.sha256(result.stdout).digest()
    return sum1 == sum2


def get_stale_files(old_dir, new_dir, ignore_exp):
    old_files = list(os.scandir(old_dir))
    stale_files = []

    purge_ignore = '_service|_keg_revisions|log_sources.*|.*changes.*'
    if ignore_exp:
        purge_ignore += '|' + ignore_exp
    ignore_regex = re.compile(purge_ignore)
    for f in old_files:
        if f.is_file() and not ignore_regex.match(f.name):
            if not os.path.exists(os.path.join(new_dir, f.name)):
                stale_files.append(f.name)

    return stale_files


def delete_unchanged_files(old_dir, new_dir, ignore_kiwi_version):
    new_files = list(os.scandir(new_dir))

    have_changes = False
    ignore_regex = re.compile('log_sources.*')
    for f in new_files:
        if not ignore_regex.match(f.name):
            if files_equivalent(f.name, old_dir, new_dir, ignore_kiwi_version):
                if f.name != 'config.kiwi':
                    logging.info('Deleting unchanged file {}'.format(f.name))
                    os.remove(f.path)
            else:
                have_changes = True

    return have_changes


def purge_files(old_dir, new_dir, purge_stale, purge_ignore, ignore_version, abort_identical):
    stale_files = []
    if purge_stale:
        stale_files = get_stale_files(old_dir, new_dir, purge_ignore)

    files_changed = delete_unchanged_files(old_dir, new_dir, ignore_version)
    if not files_changed:
        if stale_files:
            logging.info('Generated files are identical to existing ones, '
                         'but old image description has stale files, continuing.')
        else:
            logging.warning('Generated image description is identical to existing one.')
            if abort_identical:
                for f in os.listdir(new_dir):
                    os.remove(os.path.join(new_dir, f))
                logging.info('Aborting.')
                sys.exit()
    return stale_files
