import logging
import os
from pytest import raises
from unittest.mock import patch, mock_open, call, Mock

from kiwi_keg.tools import lib_fileutil


@patch('os.path.exists', return_value=False)
def test_lib_fileutil_files_equivalent_not_exist(mock_path_exists):
    assert lib_fileutil.files_equivalent('no_such_file', 'dir1', 'dir2', True) is False


@patch('kiwi_keg.tools.lib_fileutil.kiwi_files_equivalent')
@patch('os.path.exists', return_value=True)
def test_lib_fileutil_files_equivalent_kiwi(mock_path_exists, mock_files_equivalent):
    lib_fileutil.files_equivalent('config.kiwi', 'dir1', 'dir2', True)
    mock_files_equivalent.assert_called_once_with(
        os.path.join('dir1', 'config.kiwi'),
        os.path.join('dir2', 'config.kiwi'),
        True
    )


@patch('kiwi_keg.tools.lib_fileutil.tar_files_equivalent')
@patch('os.path.exists', return_value=True)
def test_lib_fileutil_files_equivalent_tar(mock_path_exists, mock_files_equivalent):
    lib_fileutil.files_equivalent('archive.tar', 'dir1', 'dir2', True)
    mock_files_equivalent.assert_called_once_with(
        os.path.join('dir1', 'archive.tar'),
        os.path.join('dir2', 'archive.tar'),
    )


@patch('filecmp.cmp')
@patch('os.path.exists', return_value=True)
def test_lib_fileutil_files_equivalent_plain(mock_path_exists, mock_cmp):
    lib_fileutil.files_equivalent('plain', 'dir1', 'dir2', True)
    mock_cmp.assert_called_once_with(
        os.path.join('dir1', 'plain'),
        os.path.join('dir2', 'plain'),
        shallow=False
    )


kiwi1 = '''<?xml version="1.0" encoding="utf-8"?>
<!-- Image description generated by keg on 2025-11-11 17:04:47 -->
<image schemaversion="7.5" name="image_name" displayname="image_display_name">
    <preferences>
        <version>1.2.3</version>
    </preferences>
'''

kiwi2 = '''<?xml version="1.0" encoding="utf-8"?>
<!-- Image description generated by keg on 2025-11-11 17:04:48 -->
<image schemaversion="7.5" name="image_name" displayname="image_display_name">
    <preferences>
        <version>1.2.4</version>
    </preferences>
'''


def test_lib_fileutil_kiwi_files_equivalent():
    mock_open_kiwi1 = mock_open(read_data=kiwi1)
    mock_open_kiwi2 = mock_open(read_data=kiwi2)
    mmo = mock_open()
    mmo.side_effect = [mock_open_kiwi1.return_value, mock_open_kiwi2.return_value]
    with patch('builtins.open', mmo):
        assert lib_fileutil.kiwi_files_equivalent('kiwi1', 'kiwi2', False) is False
        mock_open_kiwi1.assert_has_calls([call().readlines()])
        mock_open_kiwi2.assert_has_calls([call().readlines()])


def test_lib_fileutil_kiwi_files_equivalent_ignore_version():
    mock_open_kiwi1 = mock_open(read_data=kiwi1)
    mock_open_kiwi2 = mock_open(read_data=kiwi2)
    mmo = mock_open()
    mmo.side_effect = [mock_open_kiwi1.return_value, mock_open_kiwi2.return_value]
    with patch('builtins.open', mmo):
        assert lib_fileutil.kiwi_files_equivalent('kiwi1', 'kiwi2', True) is True
        mock_open_kiwi1.assert_has_calls([call().readlines()])
        mock_open_kiwi2.assert_has_calls([call().readlines()])


@patch('subprocess.run')
def test_lib_fileutil_tar_files_equivalent_false(mock_run):
    mock_content1 = Mock()
    mock_content2 = Mock()
    mock_content1.stdout = 'content1'.encode('utf-8')
    mock_content2.stdout = 'content2'.encode('utf-8')
    mock_run.side_effect = [mock_content1, mock_content2]
    assert lib_fileutil.tar_files_equivalent('file1', 'file2') is False


@patch('subprocess.run')
def test_lib_fileutil_tar_files_equivalent_true(mock_run):
    mock_content1 = Mock()
    mock_content2 = Mock()
    mock_content1.stdout = 'content'.encode('utf-8')
    mock_content2.stdout = 'content'.encode('utf-8')
    mock_run.side_effect = [mock_content1, mock_content2]
    assert lib_fileutil.tar_files_equivalent('file1', 'file2') is True


@patch('os.path.exists')
@patch('os.scandir')
def test_lib_fileutil_get_stale_files(mock_os_scandir, mock_path_exists):
    mock_file_changes = Mock()
    mock_file_changes.is_file.return_value = True
    mock_file_changes.name = 'changes.json'
    mock_file_stale = Mock()
    mock_file_stale.is_file.return_value = True
    mock_file_stale.name = 'stale_file'
    mock_file_add_ignore = Mock()
    mock_file_add_ignore.is_file.return_value = True
    mock_file_add_ignore.name = 'ignore_file'
    mock_os_scandir.return_value = [mock_file_changes, mock_file_stale, mock_file_add_ignore]
    mock_path_exists.return_value = False
    assert lib_fileutil.get_stale_files('old_dir', 'new_dir', 'ignore.*') == ['stale_file']


@patch('kiwi_keg.tools.lib_fileutil.files_equivalent', return_value=True)
@patch('os.remove')
@patch('os.scandir')
def test_lib_fileutil_delete_unchanged_files(mock_os_scandir, mock_os_remove, mock_files_equivalent):
    mock_config_kiwi = Mock()
    mock_config_kiwi.name = 'config.kiwi'
    mock_source_log = Mock()
    mock_source_log.name = 'log_sources_foo'
    mock_unchanged_file = Mock()
    mock_unchanged_file.name = 'unchanged_file'
    mock_unchanged_file.path = 'new_dir/unchanged_file'
    mock_os_scandir.return_value = [mock_config_kiwi, mock_source_log, mock_unchanged_file]
    assert lib_fileutil.delete_unchanged_files('old_dir', 'new_dir', True) is False
    mock_files_equivalent.assert_has_calls([
        call('config.kiwi', 'old_dir', 'new_dir', True),
        call('unchanged_file', 'old_dir', 'new_dir', True)
    ])
    mock_os_remove.assert_called_once_with('new_dir/unchanged_file')


@patch('kiwi_keg.tools.lib_fileutil.files_equivalent', return_value=False)
@patch('os.remove')
@patch('os.scandir')
def test_lib_fileutil_delete_unchanged_files_no_unchanged(mock_os_scandir, mock_os_remove, mock_files_equivalent):
    mock_changed_file = Mock()
    mock_changed_file.name = 'changed_file'
    mock_changed_file.path = 'new_dir/changed_file'
    mock_os_scandir.return_value = [mock_changed_file]
    assert lib_fileutil.delete_unchanged_files('old_dir', 'new_dir', True) is True
    mock_files_equivalent.assert_called_once_with('changed_file', 'old_dir', 'new_dir', True)
    mock_os_remove.assert_not_called()


@patch('kiwi_keg.tools.lib_fileutil.delete_unchanged_files', return_value=True)
def test_lib_fileutil_purge_files_have_no_purge(mock_delete_unchanged_files):
    assert lib_fileutil.purge_files('old_dir', 'new_dir', False, None, True, False) == []
    mock_delete_unchanged_files.assert_called_with('old_dir', 'new_dir', True)


@patch('kiwi_keg.tools.lib_fileutil.get_stale_files', return_value=['stale_file'])
@patch('kiwi_keg.tools.lib_fileutil.delete_unchanged_files', return_value=False)
def test_lib_fileutil_purge_files_purge_unchanged_stales(mock_delete_unchanged_files, mock_get_stale_files, caplog):
    with caplog.at_level(logging.INFO):
        assert lib_fileutil.purge_files('old_dir', 'new_dir', True, None, True, False) == ['stale_file']
    mock_delete_unchanged_files.assert_called_with('old_dir', 'new_dir', True)
    assert 'Generated files are identical to existing ones, but old image description has stale files' in caplog.text


@patch('kiwi_keg.tools.lib_fileutil.get_stale_files', return_value=[])
@patch('kiwi_keg.tools.lib_fileutil.delete_unchanged_files', return_value=False)
def test_lib_fileutil_purge_files_purge_unchanged_no_abort(mock_delete_unchanged_files, mock_get_stale_files, caplog):
    assert lib_fileutil.purge_files('old_dir', 'new_dir', True, None, True, False) == []
    assert 'Generated image description is identical' in caplog.text


@patch('kiwi_keg.tools.lib_fileutil.get_stale_files', return_value=[])
@patch('kiwi_keg.tools.lib_fileutil.delete_unchanged_files', return_value=False)
@patch('os.remove')
@patch('os.listdir', return_value=['file_to_remove'])
def test_lib_fileutil_purge_files_purge_unchanged_abort(mock_listdir, mock_remove, mock_delete_unchanged_files, mock_get_stale_files):
    with raises(SystemExit):
        lib_fileutil.purge_files('old_dir', 'new_dir', True, None, True, True)
    mock_remove.assert_called_with(os.path.join('new_dir', 'file_to_remove'))
